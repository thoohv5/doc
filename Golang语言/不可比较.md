# Golang 不可比较

# 可比较条件

两个变量如果要用“==”来比较，需要满足如下条件：

- **必须是同类型**。
    - 如果是两个接口则其中一个接口必须定义了另一个接口的全部方法；
    - 如果是结构体则必须是同一个命名结构体的两个实例或者是两个相同（包括**字段顺序相同**）的匿名结构体的实例。
- **不能是func, map, slice**
- 如果是struct的两个实例，则所有字段都必须可比较
- 如果是数组，则元素必须可比较。

> 比较引用类型是在比较其指针地址

# 特殊比较

## reflect.DeepEqual()

```go
// Equal reports whether a and b
// are the same length and contain the same bytes.
// A nil argument is equivalent to an empty slice.
func Equal(a, b []byte) bool

// As DeepEqual traverses the data values it may find a cycle. The
// second and subsequent times that DeepEqual compares two pointer
// values that have been compared before, it treats the values as
// equal rather than examining the values to which they point.
// This ensures that DeepEqual terminates.
func DeepEqual(x, y interface{}) bool
```

## cmp.Equal()

[google/go-cmp](https://github.com/google/go-cmp)

> Unlike reflect.DeepEqual, unexported fields are not compared by default; they result in panics unless suppressed by using an Ignore option (see cmpopts.IgnoreUnexported) or explicitly compared using the AllowUnexported option.

```go
func TestEqual(t *testing.T) {
	type User struct {
		UserName string
		password string
	}

	u1 := User{
		UserName: "U2",
		password: "password_for_user",
	}

	u2 := User{
		UserName: "U2",
		password: "password_for_user",
	}

	opts := []cmp.Option{
		// 忽略未导出字段
		// cmp.Comparer(func(x, y User) bool {
		// 	return u1.password == u2.password
		// }),

		// 允许比较未导出字段
		// cmp.AllowUnexported(u1, u2),
	}

	if !cmp.Equal(u1, u2, opts...) {
		t.Errorf("u1 is not equals u2")
	}
}
```

```go
// algtype1 returns the AlgKind used for comparing and hashing Type t.
// If it returns ANOEQ, it also returns the component type of t that
// makes it incomparable.
func algtype1(t *types.Type) (AlgKind, *types.Type) {
	if t.Broke() {
		return AMEM, nil
	}
	if t.Noalg() {
		return ANOEQ, t
	}

	switch t.Etype {
	case TANY, TFORW:
		// will be defined later.
		return ANOEQ, t

	case TINT8, TUINT8, TINT16, TUINT16,
		TINT32, TUINT32, TINT64, TUINT64,
		TINT, TUINT, TUINTPTR,
		TBOOL, TPTR,
		TCHAN, TUNSAFEPTR:
		return AMEM, nil

	case TFUNC, TMAP:
		return ANOEQ, t

	case TFLOAT32:
		return AFLOAT32, nil

	case TFLOAT64:
		return AFLOAT64, nil

	case TCOMPLEX64:
		return ACPLX64, nil

	case TCOMPLEX128:
		return ACPLX128, nil

	case TSTRING:
		return ASTRING, nil

	case TINTER:
		if t.IsEmptyInterface() {
			return ANILINTER, nil
		}
		return AINTER, nil

	case TSLICE:
		return ANOEQ, t

	case TARRAY:
		a, bad := algtype1(t.Elem())
		switch a {
		case AMEM:
			return AMEM, nil
		case ANOEQ:
			return ANOEQ, bad
		}

		switch t.NumElem() {
		case 0:
			// We checked above that the element type is comparable.
			return AMEM, nil
		case 1:
			// Single-element array is same as its lone element.
			return a, nil
		}

		return ASPECIAL, nil

	case TSTRUCT:
		fields := t.FieldSlice()

		// One-field struct is same as that one field alone.
		if len(fields) == 1 && !fields[0].Sym.IsBlank() {
			return algtype1(fields[0].Type)
		}

		ret := AMEM
		for i, f := range fields {
			// All fields must be comparable.
			a, bad := algtype1(f.Type)
			if a == ANOEQ {
				return ANOEQ, bad
			}

			// Blank fields, padded fields, fields with non-memory
			// equality need special compare.
			if a != AMEM || f.Sym.IsBlank() || ispaddedfield(t, i) {
				ret = ASPECIAL
			}
		}

		return ret, nil
	}

	Fatalf("algtype1: unexpected type %v", t)
	return 0, nil
}
```

# 附录

[这可能是最全的golang的"=="比较规则了吧](https://www.jianshu.com/p/a982807819fa)

[The Go Programming Language Specification](https://golang.org/ref/spec#Comparison_operators)